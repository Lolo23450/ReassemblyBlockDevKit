<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reassembly Block Development Kit</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: white; color: black; transition: background 0.3s, color 0.3s; }
        .container { display: flex; }
        .panel { width: 50%; padding: 10px; border: 1px solid #c0bcbc; margin-right: 10px; background: white; transition: background 0.3s; }
        .block-list button { display: block; margin: 6px; padding: 10px; width: 97%; transition: background 0.25s, color 0.25s; }
        .attribute-section { margin-top: 10px; }
        label { width: 97%; display: inline-block; margin-top: 2px; margin-bottom: 2px; }
        input, select { width: 100%; padding: 3px; margin-bottom: 3px; }
        #searchInput { margin-bottom: 10px; padding: 5px; width: 95%; }
        #exportBtn, #creditsBtn, #loadBtn, #darkModeBtn, #clearStorageBtn, #tutorialBtn, #compareBtn { margin-top: 10px; padding: 10px; background: green; color: white; border: none; cursor: pointer; }        #creditsBtn { background: blue; }
        #loadBtn { background-color: green; }
        #darkModeBtn { background-color: blue; }
        #clearStorageBtn { background-color: red; }
        #creditsPopup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 1px solid black; box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5); z-index: 1000; }
        #closeCredits { margin-top: 10px; padding: 5px; background: red; color: white; border: none; cursor: pointer; }
        
        /* Dark Mode Styles */
        body.dark-mode { background: #1e1e1e; color: white; }
        /* input.dark-mode, select { width: 100%; padding: 5px; margin-bottom: 5px; background: #1e1e1e; color: white; transition: background 0.25s, color 0.25s; } */
        .panel.dark-mode { background: #333; border-color: #666; }
        .block-list.dark-mode button { display: block; margin: 6px; padding: 10px; width: 97%; background: #1e1e1e; color: white;}
        .dark-mode #creditsPopup {display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1e1e1e; padding: 20px; border: 1px solid black; box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5); }
        .project-controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #projectName {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            width: 200px;
        }

        .styled-button {
            padding: 8px 16px;
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .styled-button:hover {
            background-color: #0056b3;
        }

        .styled-select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }

        .delete-button {
            background-color: #FF4136;
        }

        .delete-button:hover {
            background-color: #C0392B;
        }

        .styled-checkbox {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 14px;
        }

        .styled-checkbox input[type="checkbox"] {
            margin-right: 5px;
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        h1 {
            margin-bottom: 20px;
            border-bottom: 2px solid #ccc;
            padding-bottom: 10px;
        }

        .project-manager-panel {
            background-color: #ffffff;
            padding: 20px;
            border-bottom: 2px solid #666;
            margin-bottom: 20px;
        }

        .project-manager-panel.dark-mode {
            background-color: #333;
            border-color: #666;
            color: white;
            border-bottom: 2px solid #666;
            margin-bottom: 20px;
            transition: background 0.25s, color 0.25s; 
        }

        .project-manager-panel h2 {
            margin-top: 0;
        }

        .project-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #projectName {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            width: 200px;
        }

        .styled-button {
            padding: 8px 16px;
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .styled-button:hover {
            background-color: #0056b3;
        }

        .styled-select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }

        .delete-button {
            background-color: #FF4136;
        }

        .delete-button:hover {
            background-color: #C0392B;
        }

        .styled-checkbox {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 14px;
        }

        .styled-checkbox input[type="checkbox"] {
            margin-right: 5px;
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* Tutorial Modal Styles */
        #tutorialModal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); max-width: 600px; max-height: 80vh; overflow-y: auto; z-index: 1000; }
        #tutorialModal.dark-mode { background: #333; color: white; }
        .tutorial-step { margin-bottom: 20px; padding: 10px; border-left: 4px solid #007BFF; background: rgba(0, 123, 255, 0.1); }
        .tutorial-step h4 { margin-top: 0; color: #007BFF; }
        #closeTutorial { position: absolute; top: 10px; right: 10px; background: #FF4136; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; }
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 999; }
        /* Normal preview styles */
        #blockPreview { width: 200px; height: 200px; border: 2px solid #ccc; margin: 10px 0; position: relative; z-index: 1; }
        #blockPreview .preview-block { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        /* Comparison preview styles */
        .comparison-previews .block-preview { width: 200px; height: 200px; border: 2px solid #ccc; margin: 10px; position: relative; }
        .comparison-previews .preview-block { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        /* Common styles */
        .preview-shape { width: 100%; height: 100%; transition: all 0.3s ease; }
        .dark-mode #blockPreview,
        .dark-mode .comparison-previews .block-preview { border-color: #666; }
        .comparison-previews { display: flex; justify-content: space-around; align-items: center; margin: 20px 0; }
        .comparison-controls { display: flex; justify-content: space-between; margin-bottom: 20px; }
        .comparison-select { display: flex; gap: 10px; }
        .comparison-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        .comparison-table th,
        .comparison-table td { padding: 8px; border: 1px solid #ddd; text-align: left; }
        .comparison-table tr.different { background-color: #fff3cd; }
        .dark-mode .comparison-table tr.different { background-color: #2c2c2c; }
        .dark-mode .comparison-panel { background-color: #1a1a1a; border-color: #333; }
        .dark-mode .comparison-table th,
        .dark-mode .comparison-table td { border-color: #333; }
        /* ... existing comparison styles ... */
        .comparison-table tr.higher-dps { background-color: #d4edda; }
        .comparison-table tr.lower-dps { background-color: #f8d7da; }
        .dark-mode .comparison-table tr.higher-dps { background-color: #1e3320; }
        .dark-mode .comparison-table tr.lower-dps { background-color: #382020; }
        .drop-zone { width: 150px; height: 60px; border: 2px dashed #ccc; border-radius: 4px; margin: 10px; display: flex; align-items: center; justify-content: center; text-align: center; color: #666; transition: all 0.3s ease; }
        .drop-zone.drag-over { background-color: rgba(0, 123, 255, 0.1); border-color: #007bff; }
        .dark-mode .drop-zone { border-color: #666; color: #999; }
        .dark-mode .drop-zone.drag-over { background-color: rgba(0, 123, 255, 0.2); border-color: #0056b3; }
        .comparison-select { display: grid; grid-template-columns: auto 1fr auto 1fr; align-items: center; gap: 10px; }
        /* Shape styles */
        .shape-SQUARE { clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%); }
        .shape-HEXAGON { clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%); }
        .shape-PENTAGON { clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%); }
        .shape-OCTAGON { clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%); }
        .shape-TRI { clip-path: polygon(50% 0%, 100% 100%, 0% 100%); }
        .comparison-panel { flex: 2;  /* Take up the same space as the two panels it replaces */ margin: 10px; padding: 20px; background-color: #ffffff; border-radius: 5px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
    </style>
</head>
<body>

    <h1>Reassembly Block Development Kit</h1>
    <button id="tutorialBtn" onclick="showTutorial()" style="background: #007BFF; color: white; margin-right: 10px;">Tutorial</button>
    <button id="creditsBtn" onclick="showCredits()">Credits</button>
    <button id="darkModeBtn" onclick="toggleDarkMode()">Toggle Dark/Light Mode</button>
    <button id="exportBtn" onclick="exportBlocks()">Export blocks.lua</button>
    <button id="loadBtn" onclick="loadBlocks()">Load blocks.lua (WIP)</button>
    <button id="clearStorageBtn" onclick="clearSavedBlocks()">Clear Saved Blocks</button>
    <button id="compareBtn" onclick="showComparison()" style="background: #007BFF; color: white; margin-right: 10px;">Compare Blocks</button>

    <div class="project-manager-panel">
        <h2>Project Manager</h2>
        <div class="project-controls">
            <input type="text" id="projectName" placeholder="Enter project name">
            <button class="styled-button" onclick="saveProject()">Save Project</button>
            <button class="styled-button" onclick="loadProject()">Load Project</button>
            <select id="projectList" class="styled-select" onchange="loadSelectedProject()">
                <option value="">Select a project</option>
            </select>
            <button class="styled-button delete-button" onclick="deleteProject()">Delete Project</button>
            <label class="styled-checkbox">
                <input type="checkbox" id="autosaveToggle" onchange="toggleAutosave()"> Autosave
            </label>
        </div>
    </div>

    <div id="creditsPopup">
        <h2>Credits</h2>
        <p>Developed by: Lolo</p>
        <p>Contributors: ChatGPT, Copilot, ClickerAI Assistant</p>
        <button id="closeCredits" onclick="closeCredits()">Close</button>
    </div>
    <input type="text" id="searchInput" placeholder="Search blocks..." oninput="filterBlocks()">
    <div class="container">
        <div class="panel block-list">
            <h3>1- Select a Block Type</h3>
            <button onclick="selectBlock('Armor')">Armor</button>
            <button onclick="selectBlock('Cannon')">Cannon</button>
            <button onclick="selectBlock('Laser')">Laser</button>
            <button onclick="selectBlock('Generator')">Generator</button>
            <button onclick="selectBlock('Command')">Command Module</button>
            <button onclick="selectBlock('Thruster')">Thruster</button>
            <button onclick="selectBlock('Factory')">Factory</button>
            <button onclick="selectBlock('Shield')">Shield</button>
            <button onclick="selectBlock('Tractor')">Tractor</button>
        </div>
        <div class="panel">
            <h3>2- Select Block Attributes</h3>
            <div id="blockPreview" class="block-preview"></div>
            <div id="blockattributes"></div>
            <div id="attributes"></div>
            <div id="shroudSection" style="display: none;">
                <h3>Shrouds</h3>
                <ul id="shroudList"></ul>
            </div>
            <div id="fragmentSection" style="display: none;">
                <h3>Fragments (WIP, Only 1 Fragment per Cannon)</h3>
                <ul id="fragmentList"></ul>
            </div>
            <button id="exportBtn" onclick="exportBlocks()">Export blocks.lua</button>
        </div>
        <div class="panel block-list">
            <h3>Created Blocks</h3>
            <ul id="blockList"></ul>
        </div>
        <div class="panel comparison-panel" style="display: none;" id="comparisonPanel">
            <h3>Block Comparison</h3>
            <div class="comparison-controls">
                <div class="comparison-select">
                    <select id="block1Select" onchange="updateComparison()">
                        <option value="">Select Block 1</option>
                    </select>
                    <div id="dropZone1" class="drop-zone">
                        Drop Block Here
                    </div>
                    <select id="block2Select" onchange="updateComparison()">
                        <option value="">Select Block 2</option>
                    </select>
                    <div id="dropZone2" class="drop-zone">
                        Drop Block Here
                    </div>
                </div>
            </div>
            <div class="comparison-content">
                <div class="comparison-previews">
                    <div id="preview1" class="block-preview"></div>
                    <div id="preview2" class="block-preview"></div>
                </div>
                <div class="comparison-details"></div>
            </div>
        </div>
    </div>

    <!-- Add Tutorial Modal --> 
    <div class="modal-overlay" id="tutorialOverlay"></div>
    <div id="tutorialModal">
        <button id="closeTutorial" onclick="closeTutorial()">Ã—</button>
        <h2>How to Use the Block Development Kit</h2>
        
        <div class="tutorial-step">
            <h4>Step 1: Project Management</h4>
            <p>- Enter a project name in the "Project Manager" section<br>
            - Use "Save Project" to store your work<br>
            - Enable "Autosave" for automatic backup every 4 minutes</p>
        </div>

        <div class="tutorial-step">
            <h4>Step 2: Creating a Block</h4>
            <p>1. Click on a block type from the left panel (Armor, Cannon, etc.)<br>
            2. Fill in the general attributes (name, size, shape, etc.)<br>
            3. Configure block-specific attributes (damage for weapons, etc.)<br>
            4. Click "Add Block" to save your creation</p>
        </div>

        <div class="tutorial-step">
            <h4>Step 3: Managing Blocks</h4>
            <p>- Use the search bar to filter blocks<br>
            - Click on existing blocks to edit them<br>
            - Use "Clone" to duplicate blocks<br>
            - Use "Delete" to remove blocks</p>
        </div>

        <div class="tutorial-step">
            <h4>Step 4: Exporting</h4>
            <p>- Click "Export blocks.lua" to save your blocks as a Lua file<br>
            - Place the exported file in your Reassembly mods folder<br>
            - The default path is: users/username/Saved Games/Reassembly/mods/</p>
        </div>

        <div class="tutorial-step">
            <h4>Tips</h4>
            <p>- Use dark/light mode toggle for better visibility<br>
            - Save your work frequently<br>
            - Make backup copies of important projects</p>
        </div>
    </div>

    <script>

        let blocks = [];

        function toggleDarkMode() {
            document.body.classList.toggle("dark-mode");
            document.querySelectorAll(".panel").forEach(panel => panel.classList.toggle("dark-mode"));
            document.querySelectorAll("input").forEach(input => input.classList.toggle("dark-mode"))
            document.getElementById('creditsPopup').classList.toggle('dark-mode');
            document.querySelector('.project-manager-panel').classList.toggle('dark-mode');
            document.getElementById('tutorialModal').classList.toggle('dark-mode');
            // Save dark mode state to localStorage
            localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Load dark mode preference
            if (localStorage.getItem('darkMode') === 'true') {
                document.body.classList.add('dark-mode');
                document.querySelectorAll(".panel").forEach(panel => panel.classList.add("dark-mode"));
                document.querySelectorAll("input").forEach(input => input.classList.add("dark-mode"));
                document.getElementById('creditsPopup').classList.add('dark-mode');
                document.querySelector('.project-manager-panel').classList.add('dark-mode');
                document.getElementById('tutorialModal').classList.add('dark-mode');
            }

            // Load saved blocks from local storage
            const savedBlocks = localStorage.getItem('blocks');
            if (savedBlocks) {
                blocks = JSON.parse(savedBlocks);
                updateBlockList();
            }

            // Initialize project list
            updateProjectList();
            initializeDropZones();
        });        
        
        function showCredits() {
            document.getElementById('creditsPopup').style.display = 'block';
        }

        function closeCredits() {
            document.getElementById('creditsPopup').style.display = 'none';
        }

        function selectBlock(type) {
            // Don't process block selection if in comparison mode
            if (document.getElementById('comparisonPanel').style.display === 'block') {
                return;
            }
            
            renderAttributes({ typeargs: type, generalargs: '', name: `New ${type}`, shape: "SQUARE", size: 1, id: blocks.length + 1, group: 1, fillColor1: "#d4d4d4", fillColor2: "#959696", lineColor: "#686869", capacity: 0, cannondmg: 20, cannonrounds: 4, cannonrange: 800, cannonvel: 1000, cannonpower: 7, spread: 0, projectileSize: 1, roundsPerBurst: 1, burstiness: 0, laserdmg: 100, laserrange: 700, laserwidth: 2, laserpower: 5, lasercolor: "#ffffff", turreted: "True", health: 1, powerCapacity: 300, generatorCapacityPerSec: 75, faction: 1, thrust: 30000, points: 0, shieldradius: 40, shieldpower: 0, shieldhealth: 300, shieldregen: 100, shielddelay: 2, shieldcolor: "#00ff00", shielddamagedColor: "#ff0000", density: 1, shroudsize: 2, shroudoffset: "{0,0,0}", shroudtaper: 1, shroudshape: "SQUARE", tractorRange: 500});
            updateBlockPreview();
        }

        function filterBlocks() {
            const searchInput = document.getElementById('searchInput');
            const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
            
            const blockList = document.getElementById('blockList');
            blockList.innerHTML = '';
            
            blocks.forEach((block, index) => {
                if (searchTerm && !block.name.toLowerCase().includes(searchTerm) && 
                    !block.typeargs.toLowerCase().includes(searchTerm)) {
                    return;
                }
                
                const blockContainer = document.createElement('div');
                blockContainer.style.display = 'grid';
                blockContainer.style.gridTemplateColumns = '1fr';
                blockContainer.style.gap = '5px';
                
                let button = document.createElement('button');
                button.textContent = `${block.name} (${block.typeargs})`;
                button.onclick = () => renderAttributes(blocks[index]);
                button.style.width = '100%';
                
                // Add drag functionality
                button.draggable = true;
                button.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', block.id);
                });
                
                blockContainer.appendChild(button);
                
                const buttonGroup = document.createElement('div');
                buttonGroup.style.display = 'grid';
                buttonGroup.style.gridTemplateColumns = '1fr 1fr';
                buttonGroup.style.gap = '5px';
                
                let deleteBtn = document.createElement('button');
                deleteBtn.textContent = "Delete";
                deleteBtn.style.background = "red";
                deleteBtn.style.color = "white";
                deleteBtn.onclick = () => deleteBlock(index);
                buttonGroup.appendChild(deleteBtn);

                let cloneBtn = document.createElement('button');
                cloneBtn.textContent = "Clone";
                cloneBtn.style.background = "orange";
                cloneBtn.style.color = "white";
                cloneBtn.onclick = () => cloneBlock(index);
                buttonGroup.appendChild(cloneBtn);
                
                blockContainer.appendChild(buttonGroup);
                blockList.appendChild(blockContainer);
            });
        }

        function updateBlockPreview() {
            const previewDiv = document.getElementById('blockPreview');
            const size = document.getElementById('size') ? Math.min(parseFloat(document.getElementById('size').value), 20) : 1;
            const shape = document.getElementById('shape') ? document.getElementById('shape').value : 'SQUARE';
            const fillColor1 = document.getElementById('fillColor1') ? document.getElementById('fillColor1').value : '#d4d4d4';
            const fillColor2 = document.getElementById('fillColor2') ? document.getElementById('fillColor2').value : '#959696';
            const lineColor = document.getElementById('lineColor') ? document.getElementById('lineColor').value : '#686869';
            const blockType = document.querySelector('h4') ? document.querySelector('h4').textContent.split(' ')[0] : '';
            const isTurreted = document.getElementById('turreted') ? document.getElementById('turreted').value === 'True' : false;

            // Calculate base size (50px default, scaled by size input), with max size of 20
            const baseSize = 50 * Math.min(size, 20);
            const maxSize = 150; // Maximum size to prevent overflow
            const actualSize = Math.min(baseSize, maxSize);

            // Generate shroud HTML
            let shroudHTML = '';
            const shroudElements = document.querySelectorAll("#shroudList li");
            const shrouds = Array.from(shroudElements).map(shroudElement => {
                const shroudSize = shroudElement.querySelector(".shroud-size").value;
                const shroudOffset = shroudElement.querySelector(".shroud-offset").value;
                const shroudTaper = parseFloat(shroudElement.querySelector(".shroud-taper").value);
                const shroudShape = shroudElement.querySelector(".shroud-shape").value;

                // Parse size and offset values
                let [sizeX, sizeY] = shroudSize.replace(/[{}]/g, '').split(',').map(n => parseFloat(n));
                let [offsetX, offsetY, offsetZ] = shroudOffset.replace(/[{}]/g, '').split(',').map(n => parseFloat(n) || 0);

                // Scale values for preview
                sizeX = (sizeX * actualSize) / 20;
                sizeY = (sizeY * actualSize) / 20;
                offsetX = (offsetX * actualSize) / 20;
                offsetY = (offsetY * actualSize) / 20;

                return {
                    html: `
                        <div class="preview-shroud shape-${shroudShape}" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: ${sizeX}px;
                            height: ${sizeY}px;
                            background: linear-gradient(45deg, ${fillColor2}${Math.round(shroudTaper * 255).toString(16).padStart(2, '0')}, ${fillColor1}${Math.round(shroudTaper * 255).toString(16).padStart(2, '0')});
                            border: ${Math.max(1, size/3)}px solid ${lineColor};
                            transform: translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px));
                            z-index: ${Math.round(offsetZ * 10)};
                        "></div>
                    `,
                    zIndex: offsetZ
                };
            });

            // Sort shrouds by Z offset and combine HTML
            shroudHTML = shrouds.sort((a, b) => a.zIndex - b.zIndex)
                               .map(shroud => shroud.html)
                               .join('');

            // Calculate turret dimensions based on weapon attributes
            let turretHTML = '';
            if ((blockType === 'Cannon' || blockType === 'Laser') && isTurreted) {
                const turretSize = actualSize * 0.6; // Turret base size
                let barrelLength, barrelWidth, barrelCount = 1;
                
                if (blockType === 'Cannon') {
                    const damage = parseFloat(document.getElementById('damage')?.value || 20);
                    const velocity = parseFloat(document.getElementById('muzzleVel')?.value || 1000);
                    const roundsPerSec = parseFloat(document.getElementById('roundsPerSec')?.value || 4);
                    
                    // More pronounced scaling for damage and velocity
                    barrelLength = Math.min(turretSize * (velocity / 500) * 0.5, turretSize * 2.5);
                    barrelWidth = Math.min(turretSize * (damage / 10) * 0.15, turretSize * 0.8); // Increased damage impact
                    
                    // Calculate barrel count based on rounds per second (reduced impact)
                    barrelCount = Math.min(Math.ceil(roundsPerSec / 4), 4); // Max 4 barrels, requires higher RPS
                    
                    // Generate multiple barrels
                    let barrelsHTML = '';
                    for (let i = 0; i < barrelCount; i++) {
                        const offsetY = -barrelWidth * (barrelCount - 1) / 2 + (i * barrelWidth);
                        
                        barrelsHTML += `
                            <div class="preview-barrel" style="
                                position: absolute;
                                top: 50%;
                                left: 50%;
                                width: ${barrelLength}px;
                                height: ${barrelWidth}px;
                                background: linear-gradient(90deg, ${fillColor1}, ${fillColor2});
                                border: ${Math.max(1, size/2)}px solid ${lineColor};
                                transform: translate(0%, ${offsetY}px) translateY(-50%);
                                transform-origin: left center;
                                border-radius: ${barrelWidth / 8}px;
                            "></div>
                        `;
                    }

                    turretHTML = `
                        <div class="preview-turret" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            width: ${turretSize}px;
                            height: ${turretSize}px;
                            background: linear-gradient(45deg, ${fillColor2}, ${fillColor1});
                            border: ${Math.max(2, size)}px solid ${lineColor};
                            border-radius: 50%;
                            z-index: 2;
                        ">
                            ${barrelsHTML}
                        </div>
                    `;
                } else if (blockType === 'Laser') {
                    const damage = parseFloat(document.getElementById('laserdamage')?.value || 100);
                    const width = parseFloat(document.getElementById('laserwidth')?.value || 2);
                    barrelLength = turretSize * 1.2; // Made longer for triangle
                    barrelWidth = Math.min(turretSize * (width / 2) * 0.3, turretSize * 0.4);

                    turretHTML = `
                        <div class="preview-turret" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            width: ${turretSize}px;
                            height: ${turretSize}px;
                            background: linear-gradient(45deg, ${fillColor2}, ${fillColor1});
                            border: ${Math.max(2, size)}px solid ${lineColor};
                            border-radius: 50%;
                            z-index: 2;
                        ">
                            <div class="preview-barrel" style="
                                position: absolute;
                                top: 50%;
                                left: 50%;
                                width: ${barrelLength}px;
                                height: ${barrelWidth * 2}px;
                                background: linear-gradient(90deg, ${fillColor1}, ${fillColor2});
                                clip-path: polygon(100% 50%, 0 0, 0 100%);
                                transform: translate(0%, -50%);
                                transform-origin: left center;
                                outline: ${Math.max(2, size/2)}px solid ${lineColor};
                                outline-offset: -${Math.max(2, size/2)}px;
                            "></div>
                        </div>
                    `;
                }
            }

            // Create or update preview with adjusted z-indices
            previewDiv.innerHTML = `
                <div class="preview-block" style="width: ${actualSize}px; height: ${actualSize}px;">
                    <div class="preview-shape shape-${shape}" style="
                        background: linear-gradient(45deg, ${fillColor1}, ${fillColor2});
                        border: ${2 * Math.sqrt(size)}px solid ${lineColor};
                        width: 100%;
                        height: 100%;
                        position: relative;
                        z-index: 0;
                    "></div>
                    ${shroudHTML}
                    ${turretHTML}
                    ${blockType ? `<div style="position: absolute; top: -25px; width: 100%; text-align: center;">${blockType}</div>` : ''}
                </div>
            `;
        }

        function renderAttributes(block) {
            const shroudSection = document.getElementById('shroudSection');
            shroudSection.style.display = 'block';
            const featureAttributesDiv = document.getElementById('attributes');
            const blockAttributesDiv = document.getElementById('blockattributes');
            const shroudList = document.getElementById('shroudList');
            const fragmentList = document.getElementById('fragmentList');
            featureAttributesDiv.innerHTML = `<h4>${block.typeargs} Attributes</h4>`;
            blockAttributesDiv.innerHTML = `<h5>General Attributes</h5>`;
            let blockAttributesHTML = `<label>Name: <input type="text" id="name" value="${block.name}"></label>`;
            blockAttributesHTML += `<label>Block ID: <input type="number" id="id" value="${block.id}"></label>`;
            blockAttributesHTML += `<label>Group/Faction ID: <input type="text" id="group" value="${block.group}"></label>`;
            blockAttributesHTML += `<label>Shape: <input type="text" id="shape" value="${block.shape}"></label>`;
            blockAttributesHTML += `<label>Size: <input type="number" id="size" value="${block.size}"></label>`;
            blockAttributesHTML += `<label>Health Multiplier: <input type="number" id="health" value="${block.health}"></label>`;
            blockAttributesHTML += `<label>Density/Mass Multiplier: <input type="number" id="density" value="${block.density}"></label>`;
            blockAttributesHTML += `<label>Capacity: <input type="number" id="capacity" value="${block.capacity}"></label>`;
            blockAttributesHTML += `<label>P Cost: <input type="number" id="points" value="${block.points}"></label>`;
            blockAttributesHTML += `<label>Fill Color 1: <input type="color" id="fillColor1" value="${block.fillColor1}"></label>`;
            blockAttributesHTML += `<label>Fill Color 2: <input type="color" id="fillColor2" value="${block.fillColor2}"></label>`;
            blockAttributesHTML += `<label>Line Color: <input type="color" id="lineColor" value="${block.lineColor}"></label>`;
            shroudList.innerHTML = "";
            let shroudListHTML = `<button onclick="addShroud()">Add Shroud</button>`;
            let attributesHTML = '';
            
            if (block.typeargs === 'Cannon') {
                fragmentSection.style.display = 'block';
                attributesHTML += `
                    <label>Turreted: <select id="turreted">
                        <option value="True" ${block.turreted === "True" ? "selected" : ""}>True</option>
                        <option value="False" ${block.turreted === "False" ? "selected" : ""}>False</option>
                    </select></label>
                    <label>Damage: <input type="number" id="damage" value="${block.cannondmg}"></label>
                    <label>Rounds per Sec: <input type="number" id="roundsPerSec" value="${block.cannonrounds}"></label>
                    <label>Range: <input type="number" id="range" value="${block.cannonrange}"></label>
                    <label>Shot Velocity: <input type="number" id="muzzleVel" value="${block.cannonvel}"></label>
                    <label>Power: <input type="number" id="power" value="${block.cannonpower}"></label>
                    <label>Spread (0-3.6): <input type="number" id="spread" min="0" max="3.6" step="0.1" value="${block.spread || 0}" oninput="this.value = Math.min(Math.max(this.value, 0), 3.6)"></label>
                    <label>Projectile Size (1-100): <input type="number" id="projectileSize" min="1" max="100" value="${block.projectileSize || 1}" oninput="this.value = Math.min(Math.max(this.value, 1), 100)"></label>
                    <label>Rounds per Burst (1-100): <input type="number" id="roundsPerBurst" min="1" max="100" value="${block.roundsPerBurst || 1}" oninput="this.value = Math.min(Math.max(this.value, 1), 100)"></label>
                    <label>Burstyness (0-1): <input type="number" id="burstiness" min="0" max="1" step="0.1" value="${block.burstiness || 0}" oninput="this.value = Math.min(Math.max(this.value, 0), 1)"></label>
                `;
            } else if (block.typeargs === 'Laser') {
                attributesHTML += `
                    <label>Turreted (True/False): <input type="text" id="turreted" value="${block.turreted}"></label>
                    <label>Damage: <input type="number" id="laserdamage" value="${block.laserdmg}"></label>
                    <label>Range: <input type="number" id="laserrange" value="${block.laserrange}"></label>
                    <label>Width: <input type="number" id="laserwidth" value="${block.laserwidth}"></label>
                    <label>Power: <input type="number" id="laserpower" value="${block.laserpower}"></label>
                    <label>Color: <input type="color" id="lasercolor" value="${block.lasercolor}"></label>
                `;
            } else if (block.typeargs === 'Generator') {
                attributesHTML += `
                    <label>Power Capacity: <input type="number" id="powerCapacity" value="${block.powerCapacity}"></label>
                    <label>Generation per Sec: <input type="number" id="generatorCapacityPerSec" value="${block.generatorCapacityPerSec}"></label>
                `;
            } else if (block.typeargs === 'Command') {
                attributesHTML += `
                    <label>Faction ID: <input type="number" id="faction" value="${block.faction}"></label>
                `;
            } else if (block.typeargs === 'Thruster') {
                attributesHTML += `
                    <label>Thruster Force: <input type="number" id="thrust" value="${block.thrust}"></label>
                `;
            } else if (block.typeargs === 'Shield') {
                attributesHTML += `
                    <label>Radius: <input type="number" id="radius" value="${block.shieldradius}"></label>
                    <label>Health: <input type="number" id="shieldhealth" value="${block.shieldhealth}"></label>
                    <label>Health Regen per Sec: <input type="number" id="regen" value="${block.shieldregen}"></label>
                    <label>Delay: <input type="number" id="delay" value="${block.shielddelay}"></label>
                    <label>Color: <input type="color" id="color" value="${block.shieldcolor}"></label>
                    <label>Damaged Color: <input type="color" id="damagedColor" value="${block.shielddamagedColor}"></label>
                `;
            } else if (block.typeargs === 'Tractor') {
                attributesHTML += `
                    <label>Tractor Range: <input type="number" id="tractorRange" value="${block.tractorRange}"></label>
                `;
            }
            if (!block.shrouds) block.shrouds = [];
            if (!block.fragments) block.fragments = [];

            // Repopulate shroud list
            block.shrouds.forEach((shroud, index) => {
                let shroudItem = document.createElement("li");
                shroudItem.innerHTML = `
                    <label>Size: <input type="text" class="shroud-size" value="${shroud.size}" data-index="${index}"></label>
                    <label>Offset: <input type="text" class="shroud-offset" value="${shroud.offset}" data-index="${index}"></label>
                    <label>Taper: <input type="number" class="shroud-taper" value="${shroud.taper}" data-index="${index}"></label>
                    <label>Shape: <select class="shroud-shape" data-index="${index}">
                        <option value="SQUARE" ${shroud.shape === "SQUARE" ? "selected" : ""}>SQUARE</option>
                        <option value="HEXAGON" ${shroud.shape === "HEXAGON" ? "selected" : ""}>HEXAGON</option>
                    </select></label>
                    <button onclick="removeShroud(${index})">Remove</button>
                `;
                shroudList.appendChild(shroudItem);
            });

            // Repopulate fragment list if it's a cannon
            if (block.typeargs === 'Cannon') {
                fragmentList.innerHTML = ''; // Clear fragment list first
                block.fragments.forEach((fragment, index) => {
                    let fragmentItem = document.createElement("li");
                    fragmentItem.innerHTML = `
                        <label>Spread: <input type="number" class="fragment-spread" value="${fragment.spread}" data-index="${index}"></label>
                        <label>Range: <input type="number" class="fragment-range" value="${fragment.range}" data-index="${index}"></label>
                        <button onclick="removeFragment(${index})">Remove</button>
                    `;
                    fragmentList.appendChild(fragmentItem);
                });
                let addFragmentBtn = document.createElement("button");
                addFragmentBtn.textContent = "Add Fragment";
                addFragmentBtn.onclick = addFragment;
                fragmentList.appendChild(addFragmentBtn);
            }

            attributesHTML += `<button onclick="saveBlock()">Add Block</button>`;
            blockAttributesDiv.innerHTML += blockAttributesHTML;
            featureAttributesDiv.innerHTML += attributesHTML;
            shroudList.innerHTML += shroudListHTML;

            // Add event listeners for preview updates
            ['size', 'shape', 'fillColor1', 'fillColor2', 'lineColor', 'turreted', 'damage', 'muzzleVel', 
             'roundsPerSec', 'laserdamage', 'laserwidth'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', updateBlockPreview);
                }
            });

            // Add event listeners for shroud updates
            document.querySelectorAll('.shroud-size, .shroud-offset, .shroud-taper, .shroud-shape').forEach(element => {
                element.addEventListener('input', updateBlockPreview);
            });

            // Initial preview update
            updateBlockPreview();
        }

        function addShroud() {
            let block = blocks.find(b => b.name === document.getElementById('name').value);
            if (!block) return;

            if (!block.shrouds) block.shrouds = [];

            let shroudList = document.getElementById("shroudList");
            let shroudIndex = block.shrouds.length;
            let shroudItem = document.createElement("li");

            shroudItem.innerHTML = `
                <label>Size: <input type="text" class="shroud-size" value="{10,10}" data-index="${shroudIndex}"></label>
                <label>Offset: <input type="text" class="shroud-offset" value="{0,0,0}" data-index="${shroudIndex}"></label>
                <label>Taper: <input type="number" class="shroud-taper" value="1" data-index="${shroudIndex}"></label>
                <label>Shape: <select class="shroud-shape" data-index="${shroudIndex}">
                    <option value="TRI">TRI</option>
                    <option value="SQUARE">SQUARE</option>
                    <option value="PENTAGON">PENTAGON</option>
                    <option value="HEXAGON">HEXAGON</option>
                    <option value="HEPTAGON">HEPTAGON</option>
                    <option value="OCTAGON">OCTAGON</option>
                    <option value="COMMAND">COMMAND</option>
                </select></label>
                <button onclick="removeShroud(${shroudIndex})">Remove</button>
            `;

            shroudList.appendChild(shroudItem);

            block.shrouds.push({
                size: document.querySelector(`.shroud-size[data-index="${shroudIndex}"]`).value,
                offset: document.querySelector(`.shroud-offset[data-index="${shroudIndex}"]`).value,
                taper: document.querySelector(`.shroud-taper[data-index="${shroudIndex}"]`).value,
                shape: document.querySelector(`.shroud-shape[data-index="${shroudIndex}"]`).value
            });
        }

        function addFragment() {
            let block = blocks.find(b => b.name === document.getElementById('name').value);
            if (!block || block.typeargs !== "Cannon") return;

            if (!block.fragments) block.fragments = [];

            let fragmentList = document.getElementById("fragmentList");
            let fragmentIndex = block.fragments.length;
            let fragmentItem = document.createElement("li");

            fragmentItem.innerHTML = `
                <label>Spread: <input type="number" class="fragment-spread" value="0.2" data-index="${fragmentIndex}"></label>
                <label>Range: <input type="number" class="fragment-range" value="200" data-index="${fragmentIndex}"></label>
                <label>Damage: <input type="number" class="fragment-damage" value="10" data-index="${fragmentIndex}"></label>
                <label>Shot Velocity: <input type="number" class="fragment-muzzleVel" value="500" data-index="${fragmentIndex}"></label>
                <label>Projectile Size: <input type="number" class="fragment-projectileSize" value="1" data-index="${fragmentIndex}"></label>
                <label>Rounds Per Burst: <input type="number" class="fragment-roundsPerBurst" value="3" data-index="${fragmentIndex}"></label>
                <button onclick="removeFragment(${fragmentIndex})">Remove</button>
            `;

            fragmentList.appendChild(fragmentItem);

            block.fragments.push({
                spread: document.querySelector(`.fragment-spread[data-index="${fragmentIndex}"]`).value,
                range: document.querySelector(`.fragment-range[data-index="${fragmentIndex}"]`).value,
                damage: document.querySelector(`.fragment-damage[data-index="${fragmentIndex}"]`).value,
                muzzleVel: document.querySelector(`.fragment-muzzleVel[data-index="${fragmentIndex}"]`).value,
                projectileSize: document.querySelector(`.fragment-projectileSize[data-index="${fragmentIndex}"]`).value,
                roundsPerBurst: document.querySelector(`.fragment-roundsPerBurst[data-index="${fragmentIndex}"]`).value
            });
        }

        function removeFragment(index) {
            const block = blocks.find(b => b.name === document.getElementById('name').value);
            if (block && block.fragments) {
                // Remove the fragment element from the DOM
                const fragmentList = document.getElementById('fragmentList');
                const fragmentElements = fragmentList.getElementsByTagName('li');
                if (fragmentElements[index]) {
                    fragmentElements[index].remove();
                }
                
                // Remove the fragment from the data
                block.fragments.splice(index, 1);
                
                // Update indices of remaining fragments
                const remainingInputs = fragmentList.querySelectorAll('input');
                remainingInputs.forEach(input => {
                    const currentIndex = parseInt(input.dataset.index);
                    if (currentIndex > index) {
                        input.dataset.index = currentIndex - 1;
                    }
                });
            }
        }

        function removeShroud(index) {
            const block = blocks.find(b => b.name === document.getElementById('name').value);
            if (block) {
                block.shrouds.splice(index, 1);
                renderAttributes(block); // Re-render attributes
            }
        }

        function saveBlock() {
            let block = {
                typeargs: document.querySelector('h4') ? document.querySelector('h4').textContent.split(' ')[0] : '',
                generalargs: document.querySelector('h5') ? document.querySelector('h5').textContent.split(' ')[0] : '',
                name: document.getElementById('name') ? document.getElementById('name').value : '',
                shape: document.getElementById('shape') ? document.getElementById('shape').value : '',
                size: document.getElementById('size') ? document.getElementById('size').value : 0,
                group: document.getElementById('group') ? document.getElementById('group').value : '',
                points: document.getElementById('points') ? document.getElementById('points').value : 0,
                id: document.getElementById('id') ? document.getElementById('id').value : 0,
                health: document.getElementById('health') ? document.getElementById('health').value : 0,
                capacity: document.getElementById('capacity') ? document.getElementById('capacity').value : 0,
                fillColor1: document.getElementById('fillColor1') ? document.getElementById('fillColor1').value : '#000000',
                fillColor2: document.getElementById('fillColor2') ? document.getElementById('fillColor2').value : '#000000',
                lineColor: document.getElementById('lineColor') ? document.getElementById('lineColor').value : '#000000',
                density: document.getElementById('density') ? document.getElementById('density').value : 0,
                spread: document.getElementById('spread') ? document.getElementById('spread').value : 0,
                projectileSize: document.getElementById('projectileSize') ? document.getElementById('projectileSize').value : 1,
                roundsPerBurst: document.getElementById('roundsPerBurst') ? document.getElementById('roundsPerBurst').value : 1,
                burstiness: document.getElementById('burstiness') ? document.getElementById('burstiness').value : 0,
                shrouds: [],
                fragments: []
            };
            if (block.typeargs === "Cannon") {
                Object.assign(block, {
                    cannondmg: document.getElementById('damage').value,
                    cannonrounds: document.getElementById('roundsPerSec').value,
                    cannonrange: document.getElementById('range').value,
                    cannonvel: document.getElementById('muzzleVel').value,
                    cannonpower: document.getElementById('power').value,
                    turreted: document.getElementById('turreted').value,
                });
            } else if (block.typeargs === "Generator") {
                Object.assign(block, {
                    powerCapacity: document.getElementById('powerCapacity').value,
                    generatorCapacityPerSec: document.getElementById('generatorCapacityPerSec').value,
                });
            } else if (block.typeargs === "Command") {
                Object.assign(block, {
                    faction: document.getElementById('faction').value,
                });
            } else if (block.typeargs === "Thruster") {
                Object.assign(block, {
                    thrust: document.getElementById('thrust').value,
                });
            } else if (block.typeargs === "Laser") {
                Object.assign(block, {
                    laserdmg: document.getElementById('laserdamage').value,
                    laserrange: document.getElementById('laserrange').value,
                    laserwidth: document.getElementById('laserwidth').value,
                    laserpower: document.getElementById('laserpower').value,
                    lasercolor: document.getElementById('lasercolor').value,
                    turreted: document.getElementById('turreted').value,
                });
            } else if (block.typeargs === "Shield") {
                Object.assign(block, {
                    shieldradius: document.getElementById('radius').value,
                    shieldpower: document.getElementById('power').value,
                    shieldhealth: document.getElementById('shieldhealth').value,
                    shieldregen: document.getElementById('regen').value,
                    shielddelay: document.getElementById('delay').value,
                    shieldcolor: document.getElementById('color').value,
                    shielddamagedColor: document.getElementById('damagedColor').value,
                });
            } else if (block.typeargs === "Tractor") {
                Object.assign(block, {
                    tractorRange: document.getElementById('tractorRange').value,
                });
            }

            // Check if a block with the same ID already exists
            const existingBlockIndex = blocks.findIndex(b => b.id === block.id);
            
            if (existingBlockIndex !== -1) {
                // If block exists, ask for confirmation to overwrite
                if (confirm(`A block with ID ${block.id} already exists. Do you want to overwrite it?`)) {
                    blocks[existingBlockIndex] = block;
                } else {
                    return; // Exit if user cancels
                }
            } else {
                // If no existing block found, add as new
                blocks.push(block);
            }

            // Save blocks to local storage
            localStorage.setItem('blocks', JSON.stringify(blocks));

            // Process shrouds and update block list
            let shroudElements = document.querySelectorAll("#shroudList li");
            block.shrouds = Array.from(shroudElements).map(shroudElement => ({
                size: shroudElement.querySelector(".shroud-size").value,
                offset: shroudElement.querySelector(".shroud-offset").value,
                taper: parseFloat(shroudElement.querySelector(".shroud-taper").value),
                shape: shroudElement.querySelector(".shroud-shape").value
            }));

            updateBlockList();
            updateBlockPreview();
        }

        function deleteBlock(index) {
            if (confirm("Are you sure you want to delete this block?")) {
                blocks.splice(index, 1);
                updateBlockList();
                localStorage.setItem('blocks', JSON.stringify(blocks));
            }
        }

        function cloneBlock(index) {
        const blockToClone = blocks[index];
        const clonedBlock = { 
            ...blockToClone, 
            id: blocks.length + 1, 
            name: `${blockToClone.name} (Clone)`,
            shape: blockToClone.shape,
            size: blockToClone.size,
            group: blockToClone.group,
            fillColor1: blockToClone.fillColor1,
            fillColor2: blockToClone.fillColor2,
            lineColor: blockToClone.lineColor,
            capacity: blockToClone.capacity,
            points: blockToClone.points,
            cannondmg: blockToClone.cannondmg,
            cannonrounds: blockToClone.cannonrounds,
            cannonrange: blockToClone.cannonrange,
            cannonvel: blockToClone.cannonvel,
            cannonpower: blockToClone.cannonpower,
            laserdmg: blockToClone.laserdmg,
            laserrange: blockToClone.laserrange,
            laserwidth: blockToClone.laserwidth,
            laserpower: blockToClone.laserpower,
            lasercolor: blockToClone.lasercolor,
            turreted: blockToClone.turreted,
            health: blockToClone.health,
            powerCapacity: blockToClone.powerCapacity,
            generatorCapacityPerSec: blockToClone.generatorCapacityPerSec,
            faction: blockToClone.faction,
            thrust: blockToClone.thrust,
            shieldradius: blockToClone.shieldradius,
            shieldpower: blockToClone.shieldpower,
            shieldhealth: blockToClone.shieldhealth,
            shieldregen: blockToClone.shieldregen,
            shielddelay: blockToClone.shielddelay,
            shieldcolor: blockToClone.shieldcolor,
            shielddamagedColor: blockToClone.shielddamagedColor,
            density: blockToClone.density,
            shroudsize: blockToClone.shroudsize,
            shroudoffset: blockToClone.shroudoffset,
            shroudtaper: blockToClone.shroudtaper,
            shroudshape: blockToClone.shroudshape,
            tractorRange: blockToClone.tractorRange,
            spread: blockToClone.spread,
            projectileSize: blockToClone.projectileSize,
            roundsPerBurst: blockToClone.roundsPerBurst,
            burstiness: blockToClone.burstiness,
        };
        blocks.push(clonedBlock);
        updateBlockList();
        // Save blocks to local storage
        localStorage.setItem('blocks', JSON.stringify(blocks));

    }

        function updateBlockList() {
            const blockList = document.getElementById('blockList');
            const searchInput = document.getElementById('searchInput');
            const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
            
            blockList.innerHTML = '';
            blockList.style.display = 'grid';
            blockList.style.gridTemplateColumns = 'repeat(3, 1fr)';
            blockList.style.gap = '10px';
            blockList.style.padding = '10px';
            
            blocks.forEach((block, index) => {
                if (searchTerm && !block.name.toLowerCase().includes(searchTerm) && 
                    !block.typeargs.toLowerCase().includes(searchTerm)) {
                    return;
                }
                
                const blockContainer = document.createElement('div');
                blockContainer.style.display = 'grid';
                blockContainer.style.gridTemplateColumns = '1fr';
                blockContainer.style.gap = '5px';
                
                let button = document.createElement('button');
                button.textContent = `${block.name} (${block.typeargs})`;
                button.onclick = () => renderAttributes(blocks[index]);
                button.style.width = '100%';
                
                // Add drag functionality
                button.draggable = true;
                button.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', block.id);
                });
                
                blockContainer.appendChild(button);
                
                const buttonGroup = document.createElement('div');
                buttonGroup.style.display = 'grid';
                buttonGroup.style.gridTemplateColumns = '1fr 1fr';
                buttonGroup.style.gap = '5px';
                
                let deleteBtn = document.createElement('button');
                deleteBtn.textContent = "Delete";
                deleteBtn.style.background = "red";
                deleteBtn.style.color = "white";
                deleteBtn.onclick = () => deleteBlock(index);
                buttonGroup.appendChild(deleteBtn);

                let cloneBtn = document.createElement('button');
                cloneBtn.textContent = "Clone";
                cloneBtn.style.background = "orange";
                cloneBtn.style.color = "white";
                cloneBtn.onclick = () => cloneBlock(index);
                buttonGroup.appendChild(cloneBtn);
                
                blockContainer.appendChild(buttonGroup);
                blockList.appendChild(blockContainer);
            });
        }

    function hexToLuaColor(hex) {
        return '0x' + hex.slice(1);
    }

    function exportBlocks() {
        let luaCode = `{\n`;
        blocks.forEach((block) => {
            luaCode += `    {${block.id},\n`;
            luaCode += `        group = ${block.group},\n`;
            luaCode += `        name = "${block.name}",\n`;
            luaCode += `        fillColor = ${hexToLuaColor(block.fillColor1)},\n`;
            luaCode += `        fillColor1 = ${hexToLuaColor(block.fillColor2)},\n`;
            luaCode += `        lineColor = ${hexToLuaColor(block.lineColor)},\n`;
            luaCode += `        capacity = ${block.capacity},\n`;
            luaCode += `        durability = ${block.health},\n`;
            luaCode += `        density = ${block.density},\n`;
            luaCode += `        shape = ${block.shape},\n`;
            luaCode += `        scale = ${block.size},\n`;
            luaCode += `        points = ${block.points},\n`;
            if (block.typeargs === 'Cannon') {
                if (block.turreted === 'True') {
                    luaCode += `        features = PALETTE|CANNON|TURRET,\n`;
                } else if (block.turreted === 'False') {
                    luaCode += `        features = PALETTE|CANNON,\n`;
                }
                luaCode += `        cannon = {\n`;
                luaCode += `            damage = ${block.cannondmg || 0},\n`;
                luaCode += `            roundsPerSec = ${block.cannonrounds || 0},\n`;
                luaCode += `            range = ${block.cannonrange || 0},\n`;
                luaCode += `            muzzleVel = ${block.cannonvel || 0},\n`;
                luaCode += `            power = ${block.cannonpower || 0},\n`;
                luaCode += `            spread = ${block.spread || 0},\n`;
                luaCode += `            projectileSize = ${block.projectileSize || 1},\n`;
                luaCode += `            roundsPerBurst = ${block.roundsPerBurst || 1},\n`;
                luaCode += `            burstyness = ${block.burstiness || 0}`;

                // Handle fragments with proper nesting
                if (block.fragments && block.fragments.length > 0) {
                    let fragmentString = '';
                    // Process fragments in reverse to create nested structure
                    for (let i = block.fragments.length - 1; i >= 0; i--) {
                        const fragment = block.fragments[i];
                        if (i === block.fragments.length - 1) {
                            // Last fragment (innermost)
                            fragmentString = `,\n            fragment = {\n` +
                                `                spread = ${fragment.spread || 0},\n` +
                                `                range = ${fragment.range || 0},\n` +
                                `                damage = ${fragment.damage || 0},\n` +
                                `                muzzleVel = ${fragment.muzzleVel || 0},\n` +
                                `                projectileSize = ${fragment.projectileSize || 1},\n` +
                                `                roundsPerBurst = ${fragment.roundsPerBurst || 1}\n` +
                                `            }`;
                        } else {
                            // Wrap previous fragment string in new fragment
                            fragmentString = `,\n            fragment = {\n` +
                                `                spread = ${fragment.spread || 0},\n` +
                                `                range = ${fragment.range || 0},\n` +
                                `                damage = ${fragment.damage || 0},\n` +
                                `                muzzleVel = ${fragment.muzzleVel || 0},\n` +
                                `                projectileSize = ${fragment.projectileSize || 1},\n` +
                                `                roundsPerBurst = ${fragment.roundsPerBurst || 1}` +
                                fragmentString + `\n            }`;
                        }
                    }
                    luaCode += fragmentString;
                }
                luaCode += `\n        },\n`;
            } else if (block.typeargs === 'Laser') {
                if (block.turreted === 'True') {
                    luaCode += `        features = PALETTE|LASER|TURRET,\n`;
                } else if (block.turreted === 'False') {
                    luaCode += `        features = PALETTE|LASER,\n`;
                }
                luaCode += `        laser = {\n`;
                luaCode += `            damage = ${block.laserdmg},\n`;
                luaCode += `            range = ${block.laserrange},\n`;
                luaCode += `            width = ${block.laserwidth},\n`;
                luaCode += `            power = ${block.laserpower},\n`;
                luaCode += `            color = ${hexToLuaColor(block.lasercolor)},\n`;
                luaCode += `        },\n`;
            } else if (block.typeargs === 'Armor') {
                luaCode += `        features = PALETTE,\n`;
            } else if (block.typeargs === 'Generator') {
                luaCode += `        features = PALETTE|GENERATOR,\n`;
                luaCode += `        powerCapacity = ${block.powerCapacity},\n`;
                luaCode += `        generatorCapacityPerSec = ${block.generatorCapacityPerSec},\n`;
            } else if (block.typeargs === 'Command') {
                luaCode += `        features = COMMAND|ASSEMBLER|TRACTOR,\n`;
                luaCode += `        command = {\n`;
                luaCode += `            faction = ${block.faction},\n`;
                luaCode += `        tractorRange = 600,\n`;
                luaCode += `        },\n`;
            } else if (block.typeargs === 'Thruster') {
                luaCode += `        features = PALETTE|THRUSTER,\n`;
                luaCode += `        thrusterForce = ${block.thrust},\n`;
            } else if (block.typeargs === 'Factory') {
                luaCode += `        features = PALETTE|FACTORY,\n`;
            } else if (block.typeargs === 'Shield') {
                luaCode += `        features = PALETTE|SHIELD,\n`;
                luaCode += `        shield = {\n`;
                luaCode += `            radius = ${block.shieldradius},\n`;
                luaCode += `            strenght = ${block.shieldhealth},\n`;
                luaCode += `            regen = ${block.shieldregen},\n`;
                luaCode += `            delay = ${block.shielddelay},\n`;
                luaCode += `            color = ${hexToLuaColor(block.shieldcolor)},\n`;
                luaCode += `            damagedColor = ${hexToLuaColor(block.shielddamagedColor)},\n`;
                luaCode += `        },\n`;
            } else if (block.typeargs === 'Tractor') {
                luaCode += `        features = PALETTE|TRACTOR,\n`;
                luaCode += `        tractorRange = ${block.tractorRange},\n`;
            }
            if (block.shrouds && block.shrouds.length > 0) {
                luaCode += `        shroud = {\n`;
                block.shrouds.forEach((shroud, index) => {
                    luaCode += `            {size = ${shroud.size}, offset = ${shroud.offset}, taper = ${shroud.taper}, shape = ${shroud.shape}}`;
                    if (index < block.shrouds.length - 1) {
                        luaCode += `,`;
                    }
                    luaCode += `\n`;
                });
                luaCode += `        },\n`;
            }

            luaCode += `    },\n`;
        });
        luaCode += `}`;

        const blob = new Blob([luaCode], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = 'blocks.lua';
        document.body.appendChild(a);
        a.click();

        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function loadBlocks() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.lua';
        input.onchange = async (event) => {
            const file = event.target.files[0];
            if (file) {
                const text = await file.text();
                parseLuaBlocks(text);
            }
        };
        input.click();
    }

    function parseLuaBlocks(luaCode) {
    const blockRegex = /{\s*(\d+),([\s\S]*?)\s*},/g;
    let match;

    blocks = []; // Clear existing blocks

    while ((match = blockRegex.exec(luaCode)) !== null) {
        let block = { id: parseInt(match[1]), typeargs: "", turreted: "False" };
        let attributes = match[2];

        // Extract key-value pairs
        attributes.split("\n").forEach(line => {
            let keyValue = line.match(/\s*(\w+)\s*=\s*(.*?),/);
            if (keyValue) {
                let key = keyValue[1].trim();
                let value = keyValue[2].trim().replace(/"|,/g, "");

                // Handle special cases
                if (key === "name" || key === "shape") {
                    block[key] = value;
                } else if (key === "features") {
                    if (value.includes("CANNON")) block.typeargs = "Cannon";
                    if (value.includes("LASER")) block.typeargs = "Laser";
                    if (value.includes("TURRET")) block.turreted = "True";
                    if (value.includes("GENERATOR")) block.typeargs = "Generator";
                    if (value.includes("COMMAND")) block.typeargs = "Command";
                    if (value.includes("THRUSTER")) block.typeargs = "Thruster";
                    if (value.includes("FACTORY")) block.typeargs = "Factory";
                    if (value.includes("SHIELD")) block.typeargs = "Shield";
                    
                } else if (key === "cannon") {
                    let cannonStats = value.match(/damage\s*=\s*(\d+).*?roundsPerSec\s*=\s*(\d+).*?range\s*=\s*(\d+)/s);
                    if (cannonStats) {
                        block.cannondmg = parseInt(cannonStats[1]);
                        block.cannonrounds = parseInt(cannonStats[2]);
                        block.cannonrange = parseInt(cannonStats[3]);
                    }
                } else if (key === "laser") {
                    let laserStats = value.match(/damage\s*=\s*(\d+).*?range\s*=\s*(\d+)/s);
                    if (laserStats) {
                        block.laserdmg = parseInt(laserStats[1]);
                        block.laserrange = parseInt(laserStats[2]);
                    }
                } else if (!isNaN(value)) {
                    block[key] = parseFloat(value);
                }
            }
        });

        blocks.push(block);
    }

    updateBlockList(); // Refresh UI
}

function clearSavedBlocks() {
    if (confirm("Are you sure you want to delete all saved block data?")) {
        // Clear blocks from local storage
        localStorage.removeItem('blocks');
        
        // Clear the blocks array and update the UI
        blocks = [];
        updateBlockList();
    }
}

function saveProject() {
    const projectName = document.getElementById('projectName').value.trim();
    if (!projectName) {
        alert("Please enter a project name.");
        return;
    }

    // Save the current blocks under the project name
    localStorage.setItem(`project_${projectName}`, JSON.stringify(blocks));

    // Update the project list
    updateProjectList();
    alert(`Project "${projectName}" saved successfully.`);
}

function loadProject() {
    const projectName = document.getElementById('projectName').value.trim();
    if (!projectName) {
        alert("Please enter a project name.");
        return;
    }

    const savedBlocks = localStorage.getItem(`project_${projectName}`);
    if (savedBlocks) {
        blocks = JSON.parse(savedBlocks);
        updateBlockList();
        alert(`Project "${projectName}" loaded successfully.`);
    } else {
        alert(`No project found with the name "${projectName}".`);
    }
}

function loadSelectedProject() {
    const projectName = document.getElementById('projectList').value;
    if (projectName) {
        const savedBlocks = localStorage.getItem(`project_${projectName}`);
        if (savedBlocks) {
            blocks = JSON.parse(savedBlocks);
            updateBlockList();
            alert(`Project "${projectName}" loaded successfully.`);
        }
    }
}

function deleteProject() {
    const projectName = document.getElementById('projectList').value;
    if (!projectName) {
        alert("Please select a project to delete.");
        return;
    }

    if (confirm(`Are you sure you want to delete the project "${projectName}"?`)) {
        localStorage.removeItem(`project_${projectName}`);
        updateProjectList();
        alert(`Project "${projectName}" deleted successfully.`);
    }
}

function updateProjectList() {
    const projectList = document.getElementById('projectList');
    projectList.innerHTML = '<option value="">Select a project</option>';

    // Iterate over localStorage keys to find projects
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('project_')) {
            const projectName = key.replace('project_', '');
            const option = document.createElement('option');
            option.value = projectName;
            option.textContent = projectName;
            projectList.appendChild(option);
        }
    }
}

// Initialize project list on page load
document.addEventListener('DOMContentLoaded', () => {
    updateProjectList();
    initializeDropZones();
});

function updateProjectList() {
    const projectList = document.getElementById('projectList');
    projectList.innerHTML = '<option value="">Select a project</option>';

    // Iterate over localStorage keys to find projects
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('project_')) {
            const projectName = key.replace('project_', '');
            const option = document.createElement('option');
            option.value = projectName;
            option.textContent = projectName;
            projectList.appendChild(option);
        }
    }
}

let autosaveInterval;
let autosaveEnabled = false;

function toggleAutosave() {
    autosaveEnabled = document.getElementById('autosaveToggle').checked;
    if (autosaveEnabled) {
        startAutosave();
    } else {
        stopAutosave();
    }
}

function startAutosave() {
    const projectName = document.getElementById('projectName').value.trim();
    if (!projectName) {
        alert("Please enter a project name to enable autosave.");
        document.getElementById('autosaveToggle').checked = false;
        return;
    }

    autosaveInterval = setInterval(() => {
        saveProject();
        console.log(`Project "${projectName}" autosaved.`);
    }, 240000); // Autosave every 2 minutes
}

function stopAutosave() {
    clearInterval(autosaveInterval);
}

function showTutorial() {
    document.getElementById('tutorialModal').style.display = 'block';
    document.getElementById('tutorialOverlay').style.display = 'block';
    
    // Apply dark mode if active
    if (document.body.classList.contains('dark-mode')) {
        document.getElementById('tutorialModal').classList.add('dark-mode');
    }
}

function closeTutorial() {
    document.getElementById('tutorialModal').style.display = 'none';
    document.getElementById('tutorialOverlay').style.display = 'none';
}

// Close tutorial when clicking overlay
document.getElementById('tutorialOverlay').addEventListener('click', closeTutorial);

function showComparison() {
    const comparisonPanel = document.getElementById('comparisonPanel');
    const typeSelectionPanel = document.querySelector('.block-list:not(:last-child)');
    const attributesPanel = document.querySelector('.panel:not(.block-list)');
    const blockAttributesDiv = document.getElementById('blockattributes');
    
    // Toggle comparison mode
    if (comparisonPanel.style.display === 'block') {
        // Switch back to normal mode
        comparisonPanel.style.display = 'none';
        typeSelectionPanel.style.display = 'block';
        attributesPanel.style.display = 'block';
        
        // Clear comparison selections
        document.getElementById('block1Select').value = '';
        document.getElementById('block2Select').value = '';
        
        // Reset block attributes to default
        const defaultBlock = {
            typeargs: '',
            generalargs: '',
            name: '',
            shape: 'SQUARE',
            size: 1,
            id: blocks.length + 1,
            group: 1,
            fillColor1: "#d4d4d4",
            fillColor2: "#959696",
            lineColor: "#686869",
            capacity: 0,
            health: 1,
            points: 0,
            density: 1
        };
        
        // Reset the preview and attributes panels
        if (blockAttributesDiv) {
            blockAttributesDiv.innerHTML = '<h5>General Attributes</h5>';
        }
        
        // Clear any existing attributes
        const attributesDiv = document.getElementById('attributes');
        if (attributesDiv) {
            attributesDiv.innerHTML = '<h4>Select a Block Type</h4>';
        }
        
        // Properly reset block preview
        const previewDiv = document.getElementById('blockPreview');
        if (previewDiv) {
            previewDiv.style.display = 'block';
            previewDiv.innerHTML = '';
            // Reset all preview-related variables and call updateBlockPreview with default state
            document.querySelector('h4').textContent = 'Select a Block Type';
            document.querySelector('h5').textContent = 'General Attributes';
            updateBlockPreview();
        }
        
        // Show all panels that should be visible in create mode
        document.getElementById('blockattributes').style.display = 'block';
        document.getElementById('attributes').style.display = 'block';
        
        // Force a clean state for the preview
        setTimeout(() => {
            if (previewDiv) {
                updateBlockPreview();
            }
        }, 0);
        
    } else {
        // Check if there are at least 2 blocks to compare
        if (blocks.length < 2) {
            alert('You need at least 2 blocks to use the comparison tool.');
            return;
        }

        // Switch to comparison mode
        comparisonPanel.style.display = 'block';
        typeSelectionPanel.style.display = 'none';
        attributesPanel.style.display = 'none';
        
        // Move comparison panel to the correct position
        const container = document.querySelector('.container');
        container.insertBefore(comparisonPanel, document.querySelector('.block-list:last-child'));
        
        // Populate select boxes with only existing blocks, no "Select Block" option
        const select1 = document.getElementById('block1Select');
        const select2 = document.getElementById('block2Select');
        select1.innerHTML = '';
        select2.innerHTML = '';
        
        blocks.forEach(block => {
            const option1 = document.createElement('option');
            const option2 = document.createElement('option');
            option1.value = option2.value = block.id;
            option1.textContent = option2.textContent = `${block.name} (${block.typeargs})`;
            select1.appendChild(option1);
            select2.appendChild(option2.cloneNode(true));
        });

        // Select first block by default for each dropdown
        if (blocks.length > 0) {
            select1.value = blocks[0].id;
            select2.value = blocks.length > 1 ? blocks[1].id : blocks[0].id;
            updateComparison();
        }
        
        // Initialize drop zones when comparison panel is shown
        initializeDropZones();
    }
}

function updateComparison() {
    const block1Id = document.getElementById('block1Select').value;
    const block2Id = document.getElementById('block2Select').value;
    
    if (!block1Id || !block2Id) return;
    
    const block1 = blocks.find(b => b.id == block1Id);
    const block2 = blocks.find(b => b.id == block2Id);
    
    // Update previews
    const preview1 = document.getElementById('preview1');
    const preview2 = document.getElementById('preview2');
    
    // Create temporary elements to use existing preview function
    const tempPreviewDiv = document.createElement('div');
    tempPreviewDiv.id = 'blockPreview';
    
    // Save original preview div if it exists
    const originalPreviewDiv = document.getElementById('blockPreview');
    const originalParent = originalPreviewDiv ? originalPreviewDiv.parentNode : null;
    const originalNextSibling = originalPreviewDiv ? originalPreviewDiv.nextSibling : null;
    
    // Temporarily disable normal block selection
    const originalSelectBlock = window.selectBlock;
    window.selectBlock = () => {};
    
    // Preview block 1
    if (originalPreviewDiv) {
        originalPreviewDiv.replaceWith(tempPreviewDiv);
    }
    renderAttributes(block1);
    preview1.innerHTML = document.getElementById('blockPreview').innerHTML;
    
    // Preview block 2
    renderAttributes(block2);
    preview2.innerHTML = document.getElementById('blockPreview').innerHTML;
    
    // Restore original preview div and selectBlock function
    if (originalParent) {
        tempPreviewDiv.replaceWith(originalPreviewDiv);
    }
    window.selectBlock = originalSelectBlock;
    
    // Compare and display differences
    const comparisonDetails = document.querySelector('.comparison-details');
    comparisonDetails.innerHTML = generateComparisonTable(block1, block2);
    
    // Ensure comparison panel stays visible
    document.getElementById('comparisonPanel').style.display = 'block';
    
    // Keep type selection and attributes panels hidden
    document.querySelector('.block-list:not(:last-child)').style.display = 'none';
    document.querySelector('.panel:not(.block-list):not(.comparison-panel)').style.display = 'none';
}

function calculateDPS(block) {
    if (block.typeargs === 'Cannon') {
        const damage = parseFloat(block.cannondmg) || 0;
        const roundsPerSec = parseFloat(block.cannonrounds) || 0;
        const roundsPerBurst = parseFloat(block.roundsPerBurst) || 1;
        
        // Calculate fragments DPS if they exist
        let fragmentDPS = 0;
        if (block.fragments && block.fragments.length > 0) {
            block.fragments.forEach(fragment => {
                const fragmentDamage = parseFloat(fragment.damage) || 0;
                const fragmentRounds = parseFloat(fragment.roundsPerBurst) || 1;
                fragmentDPS += fragmentDamage * fragmentRounds;
            });
            // Fragment DPS is per shot, so multiply by rounds per second
            fragmentDPS *= roundsPerSec;
        }
        
        // Base DPS + Fragment DPS
        return (damage * roundsPerSec * roundsPerBurst) + fragmentDPS;
    } 
    else if (block.typeargs === 'Laser') {
        const damage = parseFloat(block.laserdmg) || 0;
        // Lasers do continuous damage, so DPS is just the damage value
        return damage;
    }
    return 0;
}

function generateComparisonTable(block1, block2) {
    const commonProperties = [
        { key: 'name', label: 'Name' },
        { key: 'typeargs', label: 'Type' },
        { key: 'size', label: 'Size' },
        { key: 'shape', label: 'Shape' },
        { key: 'points', label: 'Points' },
        { key: 'health', label: 'Health' },
        { key: 'capacity', label: 'Capacity' }
    ];
    
    // Add type-specific properties
    if (block1.typeargs === 'Cannon' || block2.typeargs === 'Cannon') {
        commonProperties.push(
            { key: 'cannondmg', label: 'Damage per Shot' },
            { key: 'cannonrounds', label: 'Rounds/s' },
            { key: 'cannonrange', label: 'Range' },
            { key: 'cannonvel', label: 'Velocity' },
            { key: 'cannonpower', label: 'Power' },
            { key: 'roundsPerBurst', label: 'Rounds per Burst' },
            { 
                key: 'dps', 
                label: 'DPS', 
                calculate: (block) => calculateDPS(block).toFixed(2)
            }
        );
    }
    if (block1.typeargs === 'Laser' || block2.typeargs === 'Laser') {
        commonProperties.push(
            { key: 'laserdmg', label: 'DPS' },
            { key: 'laserrange', label: 'Range' },
            { key: 'laserwidth', label: 'Width' },
            { key: 'laserpower', label: 'Power' }
        );
    }
    
    let html = `
        <table class="comparison-table">
            <tr>
                <th>Property</th>
                <th>${block1.name}</th>
                <th>${block2.name}</th>
                <th>Difference</th>
            </tr>
    `;
    
    commonProperties.forEach(prop => {
        let val1, val2;
        if (prop.calculate) {
            val1 = prop.calculate(block1);
            val2 = prop.calculate(block2);
        } else {
            val1 = block1[prop.key];
            val2 = block2[prop.key];
        }
        
        const isDifferent = val1 !== val2;
        let difference = '';
        
        // Calculate difference for numeric values
        if (!isNaN(val1) && !isNaN(val2)) {
            difference = (val2 - val1).toFixed(2);
            // Add percentage difference for DPS
            if (prop.key === 'dps' || (prop.key === 'laserdmg' && (block1.typeargs === 'Laser' || block2.typeargs === 'Laser'))) {
                const percentDiff = ((val2 - val1) / val1 * 100).toFixed(1);
                difference += ` (${percentDiff}%)`;
            }
        }
        
        // Add color coding for DPS comparison
        let rowClass = isDifferent ? 'different' : '';
        if ((prop.key === 'dps' || (prop.key === 'laserdmg' && (block1.typeargs === 'Laser' || block2.typeargs === 'Laser'))) && isDifferent) {
            rowClass += val2 > val1 ? ' higher-dps' : ' lower-dps';
        }
        
        html += `
            <tr class="${rowClass}">
                <td>${prop.label}</td>
                <td>${val1 || '-'}</td>
                <td>${val2 || '-'}</td>
                <td>${difference}</td>
            </tr>
        `;
    });
    
    html += '</table>';
    return html;
}

function initializeDropZones() {
    const dropZones = ['dropZone1', 'dropZone2'];
    const selects = ['block1Select', 'block2Select'];
    
    dropZones.forEach((zoneId, index) => {
        const zone = document.getElementById(zoneId);
        const select = document.getElementById(selects[index]);
        
        zone.addEventListener('dragover', (e) => {
            e.preventDefault();
            zone.classList.add('drag-over');
        });
        
        zone.addEventListener('dragleave', () => {
            zone.classList.remove('drag-over');
        });
        
        zone.addEventListener('drop', (e) => {
            e.preventDefault();
            zone.classList.remove('drag-over');
            
            const blockId = e.dataTransfer.getData('text/plain');
            select.value = blockId;
            updateComparison();
        });
    });
}

</script>
</body>
</html>